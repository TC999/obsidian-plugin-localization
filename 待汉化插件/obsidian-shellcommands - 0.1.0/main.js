/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source visit the plugins github repository
*/

'use strict';

var obsidian = require('obsidian');
var child_process = require('child_process');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function getVaultAbsolutePath(app) {
    // Original code was copied 2021-08-22 from https://github.com/phibr0/obsidian-open-with/blob/84f0e25ba8e8355ff83b22f4050adde4cc6763ea/main.ts#L66-L67
    // But the code has been rewritten 2021-08-27 as per https://github.com/obsidianmd/obsidian-releases/pull/433#issuecomment-906087095
    let adapter = app.vault.adapter;
    if (adapter instanceof obsidian.FileSystemAdapter) {
        return adapter.getBasePath();
    }
    return null;
}
function isWindows() {
    return process.platform === "win32";
}
function getEditor(app) {
    let view = app.workspace.getActiveViewOfType(obsidian.MarkdownView);
    if (!view) {
        console.log("getEditor(): Could not get a view. Will return null.");
        return null;
    }
    let view_mode = view.getMode(); // "preview" or "source" (can also be "live" but I don't know when that happens)
    switch (view_mode) {
        case "preview":
            // The leaf is in preview mode, which makes things difficult.
            // We could still return view.editor, but it does not work at least for getting selected text, maybe for other things, but currently this function is only used for getting selected text.
            // At this moment, just return null to indicate that we were not able to offer an editor instance which could work reliably on text selections.
            // FIXME: Find a way to work in preview mode, too!
            console.log("getEditor(): 'view' is in preview mode, and the poor guy who wrote this code, does not know how to return an editor instance that could be used for getting text selection.");
            return null;
        case "source":
            // Ensure that view.editor exists! It exists at least if this is a MarkDownView.
            if ("editor" in view) {
                // Good, it exists.
                // @ts-ignore We already know that view.editor exists.
                return view.editor;
            }
            console.log("getEditor(): 'view' does not have a property named 'editor'. Will return null.");
            return null;
    }
}

let shell_command_variable_instructions = [];
function parseShellCommandVariables(app, command, enable_notifications) {
    let shell_variables = [
        new ShellCommandVariable_Clipboard(app, enable_notifications),
        new ShellCommandVariable_Date(app, enable_notifications),
        new ShellCommandVariable_FileName(app, enable_notifications),
        new ShellCommandVariable_FilePath(app, enable_notifications),
        new ShellCommandVariable_FolderName(app, enable_notifications),
        new ShellCommandVariable_FolderPath(app, enable_notifications),
        new ShellCommandVariable_Selection(app, enable_notifications),
        new ShellCommandVariable_Title(app, enable_notifications),
        new ShellCommandVariable_VaultPath(app, enable_notifications),
    ];
    let parsed_command = command; // Create a copy of the variable because we don't want to alter the original value of 'command' during iterating its regex matches.
    let parsing_failed = false;
    shell_variables.forEach((variable) => {
        let pattern = new RegExp(variable.getPattern(), "ig"); // i: case-insensitive; g: match all occurrences instead of just the first one.
        let match;
        while ((match = pattern.exec(command)) !== null) {
            let substitute = match[0];
            let argument = null;
            if (variable.has_argument && undefined !== match[1]) {
                // Extract an argument from the match.
                argument = match[1];
            }
            let variable_value = variable.getValue(argument);
            if (null === variable_value) {
                // The variable value getter has indicated that there has been a problem (probably in the passed argument) and executing the command should be cancelled. No need to continue iterating other variables.
                parsing_failed = true;
                // TODO: Find out how to break from forEach() so that we don't need to unnecessarily iterate the rest of the variables.
            }
            else {
                parsed_command = parsed_command.replace(substitute, variable_value);
            }
        }
    });
    if (parsing_failed) {
        return null;
    }
    return parsed_command;
}
function getShellCommandVariableInstructions() {
    return shell_command_variable_instructions;
}
class ShellCommandVariable {
    constructor(app, enable_notifications) {
        this.has_argument = false;
        this.app = app;
        this.enable_notifications = enable_notifications;
    }
    getPattern() {
        let pattern = '\{\{' + this.name;
        if (this.has_argument) {
            pattern += ':(.+?)';
        }
        pattern += '\}\}';
        return pattern;
    }
    notify(message) {
        // Notifications can be disabled. This is done when previewing commands while they are being typed.
        if (this.enable_notifications) {
            let prefix = "{{" + this.name + "}}: ";
            new obsidian.Notice(prefix + message);
        }
    }
}
// DEFINE VARIABLE CLASSES BELOW
// (Keep them in alphabetical order so that the instructions will be displayed in a nice order.)
class ShellCommandVariable_Clipboard extends ShellCommandVariable {
    constructor() {
        super(...arguments);
        this.name = "clipboard";
    }
    getValue() {
        let clipboard = require("electron").clipboard;
        return clipboard.readText();
    }
}
shell_command_variable_instructions.push({
    variable_name: "{{clipboard}}",
    instructions: "Gives the content you last copied to your clipboard.",
});
class ShellCommandVariable_Date extends ShellCommandVariable {
    constructor() {
        super(...arguments);
        this.name = "date";
        this.has_argument = true;
    }
    getValue(format) {
        return obsidian.moment().format(format);
    }
}
shell_command_variable_instructions.push({
    variable_name: "{{date:format}}",
    instructions: "Gives a date/time stamp as per your liking. The \"format\" part can be customized and is mandatory. Formatting options: https://momentjs.com/docs/#/displaying/format/",
});
class ShellCommandVariable_FileName extends ShellCommandVariable {
    constructor() {
        super(...arguments);
        this.name = "file_name";
    }
    getValue() {
        let file = this.app.workspace.getActiveFile();
        if (!file) {
            this.notify("No file is active at the moment. Open a file or click a pane that has a file open.");
            return null; // null indicates that getting a value has failed and the command should not be executed.
        }
        return file.name;
    }
}
shell_command_variable_instructions.push({
    variable_name: "{{file_name}}",
    instructions: "Gives the current file name with a file extension.",
});
class ShellCommandVariable_FilePath extends ShellCommandVariable {
    constructor() {
        super(...arguments);
        this.name = "file_path";
        this.has_argument = true;
    }
    getValue(mode) {
        let active_file = this.app.workspace.getActiveFile();
        if (active_file) {
            switch (mode) {
                case "absolute":
                    return obsidian.normalizePath(getVaultAbsolutePath(this.app) + "/" + active_file.path);
                case "relative":
                    return active_file.path;
                default:
                    this.notify(`Unknown mode "${mode}"! Use "absolute" or "relative".`);
                    return null; // null indicates that getting a value has failed and the command should not be executed.
            }
        }
        else {
            this.notify("No file is active at the moment. Open a file or click a pane that has a file open.");
            return null; // null indicates that getting a value has failed and the command should not be executed.
        }
    }
}
shell_command_variable_instructions.push({
    variable_name: "{{file_path:relative}} or {{file_path:absolute}}",
    instructions: "Gives path to the current file, either as absolute from the root of the file system, or as relative from the root of the Obsidian vault.",
});
class ShellCommandVariable_FolderName extends ShellCommandVariable {
    constructor() {
        super(...arguments);
        this.name = "folder_name";
    }
    getValue() {
        let file = this.app.workspace.getActiveFile();
        if (!file) {
            this.notify("No file is active at the moment. Open a file or click a pane that has a file open.");
            return null; // null indicates that getting a value has failed and the command should not be executed.
        }
        if (!file.parent) {
            this.notify("The current file does not have a parent for some strange reason.");
            return null; // null indicates that getting a value has failed and the command should not be executed.
        }
        return file.parent.name;
    }
}
shell_command_variable_instructions.push({
    variable_name: "{{folder_name}}",
    instructions: "Gives the current file's parent folder name. No ancestor folders are included.",
});
class ShellCommandVariable_FolderPath extends ShellCommandVariable {
    constructor() {
        super(...arguments);
        this.name = "folder_path";
        this.has_argument = true;
    }
    getValue(mode) {
        let active_file = this.app.workspace.getActiveFile();
        if (active_file) {
            if (active_file.parent) {
                let folder = active_file.parent;
                switch (mode) {
                    case "absolute":
                        return obsidian.normalizePath(getVaultAbsolutePath(this.app) + "/" + folder.path);
                    case "relative":
                        return folder.path;
                    default:
                        this.notify(`Unknown mode "${mode}"! Use "absolute" or "relative".`);
                        return null; // null indicates that getting a value has failed and the command should not be executed.
                }
            }
            else {
                this.notify("The current file does not have a parent for some strange reason.");
                return null; // null indicates that getting a value has failed and the command should not be executed.
            }
        }
        else {
            this.notify("No file is active at the moment. Open a file or click a pane that has a file open.");
            return null; // null indicates that getting a value has failed and the command should not be executed.
        }
    }
}
shell_command_variable_instructions.push({
    variable_name: "{{folder_path:relative}} or {{folder_path:absolute}}",
    instructions: "Gives path to the current file's parent folder, either as absolute from the root of the file system, or as relative from the root of the Obsidian vault.",
});
class ShellCommandVariable_Selection extends ShellCommandVariable {
    constructor() {
        super(...arguments);
        this.name = "selection";
    }
    getValue() {
        let editor = getEditor(this.app);
        if (null === editor) {
            // Probably the leaf is in preview mode or some other problem happened.
            // FIXME: Make it possible to use this feature also in preview mode.
            this.notify("You need to turn editing mode on, as I'm not able to get selected text when in preview mode. Blame the one who developed this plugin! This should be fixed in the future.");
            return null;
        }
        if (editor.somethingSelected()) {
            return editor.getSelection();
        }
        return "";
    }
}
shell_command_variable_instructions.push({
    variable_name: "{{selection}}",
    instructions: "Gives the currently selected text. Atm only works in editing mode, not in preview mode!",
});
class ShellCommandVariable_Title extends ShellCommandVariable {
    constructor() {
        super(...arguments);
        this.name = "title";
    }
    getValue() {
        let active_file = this.app.workspace.getActiveFile();
        if (active_file) {
            return active_file.basename;
        }
        this.notify("No file is active at the moment. Open a file or click a pane that has a file open.");
        return null;
    }
}
shell_command_variable_instructions.push({
    variable_name: "{{title}}",
    instructions: "Gives the current file name without a file extension.",
});
class ShellCommandVariable_VaultPath extends ShellCommandVariable {
    constructor() {
        super(...arguments);
        this.name = "vault_path";
    }
    getValue() {
        return getVaultAbsolutePath(this.app);
    }
}
shell_command_variable_instructions.push({
    variable_name: "{{vault_path}}",
    instructions: "Gives the Obsidian vault's absolute path from the root of the filesystem. This is the same that is used as a default working directory if you do not define one manually. If you define a working directory manually, this variable won't give you your manually defined directory, it always gives the vault's root directory.",
});

const DEFAULT_SETTINGS = {
    working_directory: "",
    commands: []
};
class ShellCommandsPlugin extends obsidian.Plugin {
    onload() {
        return __awaiter(this, void 0, void 0, function* () {
            console.log('loading plugin');
            yield this.loadSettings();
            // Make all defined shell commands to appear in the Obsidian command list
            for (let command_id in this.settings.commands) {
                let command = this.settings.commands[command_id];
                this.registerShellCommand(parseInt(command_id), command);
            }
            this.addSettingTab(new ShellCommandsSettingsTab(this.app, this));
        });
    }
    registerShellCommand(command_id, command) {
        this.addCommand({
            id: "shell-command-" + command_id,
            name: "Execute: " + command,
            callback: () => {
                this.executeShellCommand(command);
            }
        });
    }
    executeShellCommand(command) {
        let parsed_command = parseShellCommandVariables(this.app, command, true);
        if (null === parsed_command) {
            // The command could not be parsed correctly.
            console.log("Parsing command " + command + " failed.");
            // No need to create a notice here, because the parsing process creates notices every time something goes wrong.
        }
        else {
            // The command was parsed correctly.
            console.log("Executing command " + parsed_command + " in " + this.getWorkingDirectory() + "...");
            child_process.exec(parsed_command, {
                "cwd": this.getWorkingDirectory()
            }, (error) => {
                if (null !== error) {
                    // Some error occurred
                    console.log("Command executed and failed. Error number: " + error.code + ". Message: " + error.message);
                    new obsidian.Notice("[" + error.code + "]: " + error.message);
                }
                else {
                    // No errors
                    console.log("Command executed without errors.");
                }
            });
        }
    }
    getWorkingDirectory() {
        // Returns either a user defined working directory, or an automatically detected one.
        let working_directory = this.settings.working_directory;
        if (working_directory.length == 0) {
            return getVaultAbsolutePath(this.app);
        }
        return working_directory;
    }
    onunload() {
        console.log('unloading plugin');
    }
    loadSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
        });
    }
    saveSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.saveData(this.settings);
        });
    }
}
class ShellCommandsSettingsTab extends obsidian.PluginSettingTab {
    constructor(app, plugin) {
        super(app, plugin);
        this.plugin = plugin;
        this.commands = this.plugin.settings.commands;
    }
    display() {
        let { containerEl } = this;
        containerEl.empty();
        containerEl.createEl('h2', { text: "Shell commands" });
        // "Working directory" field
        new obsidian.Setting(containerEl)
            .setName("Working directory")
            .setDesc("Enter a directory where your commands will be run. If empty, defaults to your vault's location.")
            .addText(text => text
            .setPlaceholder(getVaultAbsolutePath(this.app))
            .setValue(this.plugin.settings.working_directory)
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            console.log("Changing working_directory to " + value);
            this.plugin.settings.working_directory = value;
            yield this.plugin.saveSettings();
        })));
        // Tips when the user has already defined some commands
        if (this.commands.length > 0) {
            containerEl.createEl('p', { text: "To remove a command, clear its text field. Note that if you remove commands, other shell commands can switch place and hotkeys might change! Always check your shell commands' hotkey configurations after removing or making changes to shell commands!" });
            if (isWindows())
                containerEl.createEl('p', { text: "Tip for Windows: If you get an error starting with \"[259]: Command failed:\" even though the execution works ok, you can try to prefix your command with \"start \". E.g. \"start git-gui\"." });
        }
        // A <div> element for all command input fields. New command fields can be created at the bottom of this element.
        let command_fields_container = containerEl.createEl("div");
        // Fields for modifying existing commands
        for (let command_id in this.commands) {
            this.createCommandField(command_fields_container, parseInt(command_id));
        }
        // "Apply changes" button
        new obsidian.Setting(containerEl)
            .setDesc("Click this when you make changes to commands. Other settings are applied automatically.")
            .addButton(button => button
            .setButtonText("APPLY CHANGES")
            .onClick(() => __awaiter(this, void 0, void 0, function* () {
            console.log("Updating shell command settings...");
            for (let command_id in this.commands) {
                let command = this.commands[command_id];
                if (command.length > 0) {
                    // Define/change a command
                    console.log("Command " + command_id + " gonna change to: " + command);
                    this.plugin.settings.commands[command_id] = command;
                    this.plugin.registerShellCommand(parseInt(command_id), command);
                    // TODO: How to remove the old command from Obsidian commands list?
                    console.log("Command changed.");
                }
                else {
                    // Remove a command
                    console.log("Command " + command_id + " gonna be removed.");
                    this.plugin.settings.commands.splice(parseInt(command_id), 1); // Why .remove() does not work? :( :( :(
                    // TODO: How to remove a command from Obsidian commands list?
                    console.log("Command removed.");
                }
            }
            yield this.plugin.saveSettings();
            console.log("Shell command settings updated.");
            new obsidian.Notice("Applied!");
        })));
        // "New command" button
        new obsidian.Setting(containerEl)
            .addButton(button => button
            .setButtonText("New command")
            .onClick(() => __awaiter(this, void 0, void 0, function* () {
            this.commands.push(""); // The command is just an empty string at this point.
            this.createCommandField(command_fields_container, this.commands.length - 1);
            console.log("New empty command created.");
            new obsidian.Notice("Remember to click APPLY CHANGES after you have written the new command!");
        })));
        // Variable instructions
        containerEl.createEl("h2", { text: "Variables" });
        getShellCommandVariableInstructions().forEach((instructions) => {
            let paragraph = containerEl.createEl("p");
            // @ts-ignore
            paragraph.createEl("strong", { text: instructions.variable_name + " " });
            // @ts-ignore
            paragraph.createEl("span", { text: instructions.instructions });
        });
        containerEl.createEl("p", { text: "When you type variables into commands, a preview text appears under the command field to show how the command will look like when it gets executed with variables substituted with their real values." });
        containerEl.createEl("p", { text: "There is no way to escape variable parsing. If you need {{ }} characters in your command, they won't be parsed as variables as long as they do not contain any of the variable names listed below. If you would need to pass e.g. {{title}} literally to your command, there is no way to do it atm, please raise an issue in GitHub." });
        containerEl.createEl("p", { text: "All variables that access the current file, may cause the command preview to fail if you had no file panel active when you opened the settings window - e.g. you had focus on graph view instead of a note = no file is currently active. But this does not break anything else than the preview." });
    }
    createCommandField(container_element, command_id) {
        let command = this.commands[command_id];
        let setting = new obsidian.Setting(container_element)
            .setName("Command #" + command_id)
            .setDesc(this.getCommandPreview(command))
            .addText(text => text
            .setPlaceholder("Enter your command")
            .setValue(command)
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            this.commands[command_id] = value;
            setting.setDesc(this.getCommandPreview(value));
        })));
    }
    getCommandPreview(command) {
        let parsed_command = parseShellCommandVariables(this.app, command, false); // false: disables notifications if variables have syntax errors.
        if (null === parsed_command) {
            return "[Error while parsing variables.]";
        }
        return parsed_command;
    }
}

module.exports = ShellCommandsPlugin;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZXMiOlsibm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyIsIkNvbW1vbi50cyIsIlNoZWxsQ29tbWFuZFZhcmlhYmxlUGFyc2VyLnRzIiwibWFpbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2NyZWF0ZUJpbmRpbmcgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIG8pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcCkpIF9fY3JlYXRlQmluZGluZyhvLCBtLCBwKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuLyoqIEBkZXByZWNhdGVkICovXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuLyoqIEBkZXByZWNhdGVkICovXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcclxuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcclxuICAgIHJldHVybiByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xyXG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XHJcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG59XHJcbiIsImltcG9ydCB7QXBwLCBFZGl0b3IsIEZpbGVTeXN0ZW1BZGFwdGVyLCBNYXJrZG93blZpZXd9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFZhdWx0QWJzb2x1dGVQYXRoKGFwcDogQXBwKSB7XHJcbiAgICAvLyBPcmlnaW5hbCBjb2RlIHdhcyBjb3BpZWQgMjAyMS0wOC0yMiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9waGlicjAvb2JzaWRpYW4tb3Blbi13aXRoL2Jsb2IvODRmMGUyNWJhOGU4MzU1ZmY4M2IyMmY0MDUwYWRkZTRjYzY3NjNlYS9tYWluLnRzI0w2Ni1MNjdcclxuICAgIC8vIEJ1dCB0aGUgY29kZSBoYXMgYmVlbiByZXdyaXR0ZW4gMjAyMS0wOC0yNyBhcyBwZXIgaHR0cHM6Ly9naXRodWIuY29tL29ic2lkaWFubWQvb2JzaWRpYW4tcmVsZWFzZXMvcHVsbC80MzMjaXNzdWVjb21tZW50LTkwNjA4NzA5NVxyXG4gICAgbGV0IGFkYXB0ZXIgPSBhcHAudmF1bHQuYWRhcHRlcjtcclxuICAgIGlmIChhZGFwdGVyIGluc3RhbmNlb2YgRmlsZVN5c3RlbUFkYXB0ZXIpIHtcclxuICAgICAgICByZXR1cm4gYWRhcHRlci5nZXRCYXNlUGF0aCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1dpbmRvd3MoKSB7XHJcbiAgICByZXR1cm4gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RWRpdG9yKGFwcDogQXBwKTogRWRpdG9yIHtcclxuICAgIGxldCB2aWV3ID0gYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVWaWV3T2ZUeXBlKE1hcmtkb3duVmlldyk7XHJcbiAgICBpZiAoIXZpZXcpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcImdldEVkaXRvcigpOiBDb3VsZCBub3QgZ2V0IGEgdmlldy4gV2lsbCByZXR1cm4gbnVsbC5cIik7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBsZXQgdmlld19tb2RlID0gdmlldy5nZXRNb2RlKCk7IC8vIFwicHJldmlld1wiIG9yIFwic291cmNlXCIgKGNhbiBhbHNvIGJlIFwibGl2ZVwiIGJ1dCBJIGRvbid0IGtub3cgd2hlbiB0aGF0IGhhcHBlbnMpXHJcbiAgICBzd2l0Y2ggKHZpZXdfbW9kZSkge1xyXG4gICAgICAgIGNhc2UgXCJwcmV2aWV3XCI6XHJcbiAgICAgICAgICAgIC8vIFRoZSBsZWFmIGlzIGluIHByZXZpZXcgbW9kZSwgd2hpY2ggbWFrZXMgdGhpbmdzIGRpZmZpY3VsdC5cclxuICAgICAgICAgICAgLy8gV2UgY291bGQgc3RpbGwgcmV0dXJuIHZpZXcuZWRpdG9yLCBidXQgaXQgZG9lcyBub3Qgd29yayBhdCBsZWFzdCBmb3IgZ2V0dGluZyBzZWxlY3RlZCB0ZXh0LCBtYXliZSBmb3Igb3RoZXIgdGhpbmdzLCBidXQgY3VycmVudGx5IHRoaXMgZnVuY3Rpb24gaXMgb25seSB1c2VkIGZvciBnZXR0aW5nIHNlbGVjdGVkIHRleHQuXHJcbiAgICAgICAgICAgIC8vIEF0IHRoaXMgbW9tZW50LCBqdXN0IHJldHVybiBudWxsIHRvIGluZGljYXRlIHRoYXQgd2Ugd2VyZSBub3QgYWJsZSB0byBvZmZlciBhbiBlZGl0b3IgaW5zdGFuY2Ugd2hpY2ggY291bGQgd29yayByZWxpYWJseSBvbiB0ZXh0IHNlbGVjdGlvbnMuXHJcbiAgICAgICAgICAgIC8vIEZJWE1FOiBGaW5kIGEgd2F5IHRvIHdvcmsgaW4gcHJldmlldyBtb2RlLCB0b28hXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZ2V0RWRpdG9yKCk6ICd2aWV3JyBpcyBpbiBwcmV2aWV3IG1vZGUsIGFuZCB0aGUgcG9vciBndXkgd2hvIHdyb3RlIHRoaXMgY29kZSwgZG9lcyBub3Qga25vdyBob3cgdG8gcmV0dXJuIGFuIGVkaXRvciBpbnN0YW5jZSB0aGF0IGNvdWxkIGJlIHVzZWQgZm9yIGdldHRpbmcgdGV4dCBzZWxlY3Rpb24uXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICBjYXNlIFwic291cmNlXCI6XHJcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IHZpZXcuZWRpdG9yIGV4aXN0cyEgSXQgZXhpc3RzIGF0IGxlYXN0IGlmIHRoaXMgaXMgYSBNYXJrRG93blZpZXcuXHJcbiAgICAgICAgICAgIGlmIChcImVkaXRvclwiIGluIHZpZXcpIHtcclxuICAgICAgICAgICAgICAgIC8vIEdvb2QsIGl0IGV4aXN0cy5cclxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgV2UgYWxyZWFkeSBrbm93IHRoYXQgdmlldy5lZGl0b3IgZXhpc3RzLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZXcuZWRpdG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZ2V0RWRpdG9yKCk6ICd2aWV3JyBkb2VzIG5vdCBoYXZlIGEgcHJvcGVydHkgbmFtZWQgJ2VkaXRvcicuIFdpbGwgcmV0dXJuIG51bGwuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBFcnJvcihcImdldEVkaXRvcigpOiBVbnJlY29nbmlzZWQgdmlldyBtb2RlOiBcIit2aWV3X21vZGUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxufSIsImltcG9ydCB7QXBwLCBtb21lbnQsIG5vcm1hbGl6ZVBhdGgsIE5vdGljZX0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB7Z2V0RWRpdG9yLCBnZXRWYXVsdEFic29sdXRlUGF0aH0gZnJvbSBcIi4vQ29tbW9uXCI7XHJcblxyXG5sZXQgc2hlbGxfY29tbWFuZF92YXJpYWJsZV9pbnN0cnVjdGlvbnM6IE9iamVjdFtdID0gW107XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTaGVsbENvbW1hbmRWYXJpYWJsZXMoYXBwOiBBcHAsIGNvbW1hbmQ6IHN0cmluZywgZW5hYmxlX25vdGlmaWNhdGlvbnM6IGJvb2xlYW4pIHtcclxuICAgIGxldCBzaGVsbF92YXJpYWJsZXM6IFNoZWxsQ29tbWFuZFZhcmlhYmxlW10gPSBbXHJcbiAgICAgICAgbmV3IFNoZWxsQ29tbWFuZFZhcmlhYmxlX0NsaXBib2FyZChhcHAsIGVuYWJsZV9ub3RpZmljYXRpb25zKSxcclxuICAgICAgICBuZXcgU2hlbGxDb21tYW5kVmFyaWFibGVfRGF0ZShhcHAsIGVuYWJsZV9ub3RpZmljYXRpb25zKSxcclxuICAgICAgICBuZXcgU2hlbGxDb21tYW5kVmFyaWFibGVfRmlsZU5hbWUoYXBwLCBlbmFibGVfbm90aWZpY2F0aW9ucyksXHJcbiAgICAgICAgbmV3IFNoZWxsQ29tbWFuZFZhcmlhYmxlX0ZpbGVQYXRoKGFwcCwgZW5hYmxlX25vdGlmaWNhdGlvbnMpLFxyXG4gICAgICAgIG5ldyBTaGVsbENvbW1hbmRWYXJpYWJsZV9Gb2xkZXJOYW1lKGFwcCwgZW5hYmxlX25vdGlmaWNhdGlvbnMpLFxyXG4gICAgICAgIG5ldyBTaGVsbENvbW1hbmRWYXJpYWJsZV9Gb2xkZXJQYXRoKGFwcCwgZW5hYmxlX25vdGlmaWNhdGlvbnMpLFxyXG4gICAgICAgIG5ldyBTaGVsbENvbW1hbmRWYXJpYWJsZV9TZWxlY3Rpb24oYXBwLCBlbmFibGVfbm90aWZpY2F0aW9ucyksXHJcbiAgICAgICAgbmV3IFNoZWxsQ29tbWFuZFZhcmlhYmxlX1RpdGxlKGFwcCwgZW5hYmxlX25vdGlmaWNhdGlvbnMpLFxyXG4gICAgICAgIG5ldyBTaGVsbENvbW1hbmRWYXJpYWJsZV9WYXVsdFBhdGgoYXBwLCBlbmFibGVfbm90aWZpY2F0aW9ucyksXHJcbiAgICBdO1xyXG4gICAgbGV0IHBhcnNlZF9jb21tYW5kID0gY29tbWFuZDsgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgdmFyaWFibGUgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIGFsdGVyIHRoZSBvcmlnaW5hbCB2YWx1ZSBvZiAnY29tbWFuZCcgZHVyaW5nIGl0ZXJhdGluZyBpdHMgcmVnZXggbWF0Y2hlcy5cclxuICAgIGxldCBwYXJzaW5nX2ZhaWxlZCA9IGZhbHNlO1xyXG4gICAgc2hlbGxfdmFyaWFibGVzLmZvckVhY2goKHZhcmlhYmxlOiBTaGVsbENvbW1hbmRWYXJpYWJsZSkgPT4ge1xyXG4gICAgICAgIGxldCBwYXR0ZXJuID0gbmV3IFJlZ0V4cCh2YXJpYWJsZS5nZXRQYXR0ZXJuKCksIFwiaWdcIik7IC8vIGk6IGNhc2UtaW5zZW5zaXRpdmU7IGc6IG1hdGNoIGFsbCBvY2N1cnJlbmNlcyBpbnN0ZWFkIG9mIGp1c3QgdGhlIGZpcnN0IG9uZS5cclxuICAgICAgICBsZXQgbWF0Y2g7XHJcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IHBhdHRlcm4uZXhlYyhjb21tYW5kKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgbGV0IHN1YnN0aXR1dGUgPSBtYXRjaFswXTtcclxuICAgICAgICAgICAgbGV0IGFyZ3VtZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKHZhcmlhYmxlLmhhc19hcmd1bWVudCAmJiB1bmRlZmluZWQgIT09IG1hdGNoWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGFuIGFyZ3VtZW50IGZyb20gdGhlIG1hdGNoLlxyXG4gICAgICAgICAgICAgICAgYXJndW1lbnQgPSBtYXRjaFsxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgdmFyaWFibGVfdmFsdWUgPSB2YXJpYWJsZS5nZXRWYWx1ZShhcmd1bWVudCk7XHJcbiAgICAgICAgICAgIGlmIChudWxsID09PSB2YXJpYWJsZV92YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHZhcmlhYmxlIHZhbHVlIGdldHRlciBoYXMgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaGFzIGJlZW4gYSBwcm9ibGVtIChwcm9iYWJseSBpbiB0aGUgcGFzc2VkIGFyZ3VtZW50KSBhbmQgZXhlY3V0aW5nIHRoZSBjb21tYW5kIHNob3VsZCBiZSBjYW5jZWxsZWQuIE5vIG5lZWQgdG8gY29udGludWUgaXRlcmF0aW5nIG90aGVyIHZhcmlhYmxlcy5cclxuICAgICAgICAgICAgICAgIHBhcnNpbmdfZmFpbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IEZpbmQgb3V0IGhvdyB0byBicmVhayBmcm9tIGZvckVhY2goKSBzbyB0aGF0IHdlIGRvbid0IG5lZWQgdG8gdW5uZWNlc3NhcmlseSBpdGVyYXRlIHRoZSByZXN0IG9mIHRoZSB2YXJpYWJsZXMuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBwYXJzZWRfY29tbWFuZCA9IHBhcnNlZF9jb21tYW5kLnJlcGxhY2Uoc3Vic3RpdHV0ZSwgdmFyaWFibGVfdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBpZiAocGFyc2luZ19mYWlsZWQpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBwYXJzZWRfY29tbWFuZDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNoZWxsQ29tbWFuZFZhcmlhYmxlSW5zdHJ1Y3Rpb25zKCkge1xyXG4gICAgcmV0dXJuIHNoZWxsX2NvbW1hbmRfdmFyaWFibGVfaW5zdHJ1Y3Rpb25zO1xyXG59XHJcblxyXG5hYnN0cmFjdCBjbGFzcyBTaGVsbENvbW1hbmRWYXJpYWJsZSB7XHJcbiAgICByZWFkb25seSBhcHA6IEFwcDtcclxuICAgIHJlYWRvbmx5IGVuYWJsZV9ub3RpZmljYXRpb25zOiBib29sZWFuO1xyXG4gICAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xyXG4gICAgcmVhZG9ubHkgaGFzX2FyZ3VtZW50OiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIGVuYWJsZV9ub3RpZmljYXRpb25zOiBib29sZWFuKSB7XHJcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XHJcbiAgICAgICAgdGhpcy5lbmFibGVfbm90aWZpY2F0aW9ucyA9IGVuYWJsZV9ub3RpZmljYXRpb25zO1xyXG4gICAgfVxyXG5cclxuICAgIGFic3RyYWN0IGdldFZhbHVlKGFyZ3VtZW50OiBzdHJpbmcpOiBzdHJpbmd8bnVsbDtcclxuXHJcbiAgICBnZXRQYXR0ZXJuKCkge1xyXG4gICAgICAgIGxldCBwYXR0ZXJuID0gJ1xce1xceycgKyB0aGlzLm5hbWU7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzX2FyZ3VtZW50KSB7XHJcbiAgICAgICAgICAgIHBhdHRlcm4gKz0gJzooLis/KSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhdHRlcm4gKz0gJ1xcfVxcfSc7XHJcbiAgICAgICAgcmV0dXJuIHBhdHRlcm47XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIG5vdGlmeShtZXNzYWdlOiBzdHJpbmcpIHtcclxuICAgICAgICAvLyBOb3RpZmljYXRpb25zIGNhbiBiZSBkaXNhYmxlZC4gVGhpcyBpcyBkb25lIHdoZW4gcHJldmlld2luZyBjb21tYW5kcyB3aGlsZSB0aGV5IGFyZSBiZWluZyB0eXBlZC5cclxuICAgICAgICBpZiAodGhpcy5lbmFibGVfbm90aWZpY2F0aW9ucykge1xyXG4gICAgICAgICAgICBsZXQgcHJlZml4ID0gXCJ7e1wiICsgdGhpcy5uYW1lICsgXCJ9fTogXCI7XHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UocHJlZml4ICsgbWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLy8gREVGSU5FIFZBUklBQkxFIENMQVNTRVMgQkVMT1dcclxuLy8gKEtlZXAgdGhlbSBpbiBhbHBoYWJldGljYWwgb3JkZXIgc28gdGhhdCB0aGUgaW5zdHJ1Y3Rpb25zIHdpbGwgYmUgZGlzcGxheWVkIGluIGEgbmljZSBvcmRlci4pXHJcblxyXG5jbGFzcyBTaGVsbENvbW1hbmRWYXJpYWJsZV9DbGlwYm9hcmQgZXh0ZW5kcyBTaGVsbENvbW1hbmRWYXJpYWJsZSB7XHJcbiAgICBuYW1lID0gXCJjbGlwYm9hcmRcIjtcclxuXHJcbiAgICBnZXRWYWx1ZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIGxldCBjbGlwYm9hcmQgPSByZXF1aXJlKFwiZWxlY3Ryb25cIikuY2xpcGJvYXJkO1xyXG4gICAgICAgIHJldHVybiBjbGlwYm9hcmQucmVhZFRleHQoKTtcclxuICAgIH1cclxufVxyXG5zaGVsbF9jb21tYW5kX3ZhcmlhYmxlX2luc3RydWN0aW9ucy5wdXNoKHtcclxuICAgIHZhcmlhYmxlX25hbWU6IFwie3tjbGlwYm9hcmR9fVwiLFxyXG4gICAgaW5zdHJ1Y3Rpb25zOiBcIkdpdmVzIHRoZSBjb250ZW50IHlvdSBsYXN0IGNvcGllZCB0byB5b3VyIGNsaXBib2FyZC5cIixcclxufSk7XHJcblxyXG5jbGFzcyBTaGVsbENvbW1hbmRWYXJpYWJsZV9EYXRlIGV4dGVuZHMgU2hlbGxDb21tYW5kVmFyaWFibGUge1xyXG4gICAgbmFtZSA9IFwiZGF0ZVwiO1xyXG4gICAgaGFzX2FyZ3VtZW50ID0gdHJ1ZTtcclxuXHJcbiAgICBnZXRWYWx1ZShmb3JtYXQ6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIG1vbWVudCgpLmZvcm1hdChmb3JtYXQpO1xyXG4gICAgfVxyXG59XHJcbnNoZWxsX2NvbW1hbmRfdmFyaWFibGVfaW5zdHJ1Y3Rpb25zLnB1c2goe1xyXG4gICAgdmFyaWFibGVfbmFtZTogXCJ7e2RhdGU6Zm9ybWF0fX1cIixcclxuICAgIGluc3RydWN0aW9uczogXCJHaXZlcyBhIGRhdGUvdGltZSBzdGFtcCBhcyBwZXIgeW91ciBsaWtpbmcuIFRoZSBcXFwiZm9ybWF0XFxcIiBwYXJ0IGNhbiBiZSBjdXN0b21pemVkIGFuZCBpcyBtYW5kYXRvcnkuIEZvcm1hdHRpbmcgb3B0aW9uczogaHR0cHM6Ly9tb21lbnRqcy5jb20vZG9jcy8jL2Rpc3BsYXlpbmcvZm9ybWF0L1wiLFxyXG59KTtcclxuXHJcbmNsYXNzIFNoZWxsQ29tbWFuZFZhcmlhYmxlX0ZpbGVOYW1lIGV4dGVuZHMgU2hlbGxDb21tYW5kVmFyaWFibGV7XHJcbiAgICBuYW1lID0gXCJmaWxlX25hbWVcIjtcclxuICAgIGdldFZhbHVlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgbGV0IGZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xyXG4gICAgICAgIGlmICghZmlsZSkge1xyXG4gICAgICAgICAgICB0aGlzLm5vdGlmeShcIk5vIGZpbGUgaXMgYWN0aXZlIGF0IHRoZSBtb21lbnQuIE9wZW4gYSBmaWxlIG9yIGNsaWNrIGEgcGFuZSB0aGF0IGhhcyBhIGZpbGUgb3Blbi5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBudWxsIGluZGljYXRlcyB0aGF0IGdldHRpbmcgYSB2YWx1ZSBoYXMgZmFpbGVkIGFuZCB0aGUgY29tbWFuZCBzaG91bGQgbm90IGJlIGV4ZWN1dGVkLlxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmlsZS5uYW1lO1xyXG4gICAgfVxyXG59XHJcbnNoZWxsX2NvbW1hbmRfdmFyaWFibGVfaW5zdHJ1Y3Rpb25zLnB1c2goe1xyXG4gICAgdmFyaWFibGVfbmFtZTogXCJ7e2ZpbGVfbmFtZX19XCIsXHJcbiAgICBpbnN0cnVjdGlvbnM6IFwiR2l2ZXMgdGhlIGN1cnJlbnQgZmlsZSBuYW1lIHdpdGggYSBmaWxlIGV4dGVuc2lvbi5cIixcclxufSk7XHJcblxyXG5jbGFzcyBTaGVsbENvbW1hbmRWYXJpYWJsZV9GaWxlUGF0aCBleHRlbmRzIFNoZWxsQ29tbWFuZFZhcmlhYmxle1xyXG4gICAgbmFtZSA9IFwiZmlsZV9wYXRoXCI7XHJcbiAgICBoYXNfYXJndW1lbnQgPSB0cnVlO1xyXG4gICAgZ2V0VmFsdWUobW9kZTogc3RyaW5nKTogc3RyaW5nfG51bGwge1xyXG4gICAgICAgIGxldCBhY3RpdmVfZmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XHJcbiAgICAgICAgaWYgKGFjdGl2ZV9maWxlKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAobW9kZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImFic29sdXRlXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVBhdGgoZ2V0VmF1bHRBYnNvbHV0ZVBhdGgodGhpcy5hcHApICsgXCIvXCIgKyBhY3RpdmVfZmlsZS5wYXRoKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZWxhdGl2ZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY3RpdmVfZmlsZS5wYXRoO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeShgVW5rbm93biBtb2RlIFwiJHttb2RlfVwiISBVc2UgXCJhYnNvbHV0ZVwiIG9yIFwicmVsYXRpdmVcIi5gKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gbnVsbCBpbmRpY2F0ZXMgdGhhdCBnZXR0aW5nIGEgdmFsdWUgaGFzIGZhaWxlZCBhbmQgdGhlIGNvbW1hbmQgc2hvdWxkIG5vdCBiZSBleGVjdXRlZC5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubm90aWZ5KFwiTm8gZmlsZSBpcyBhY3RpdmUgYXQgdGhlIG1vbWVudC4gT3BlbiBhIGZpbGUgb3IgY2xpY2sgYSBwYW5lIHRoYXQgaGFzIGEgZmlsZSBvcGVuLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIG51bGwgaW5kaWNhdGVzIHRoYXQgZ2V0dGluZyBhIHZhbHVlIGhhcyBmYWlsZWQgYW5kIHRoZSBjb21tYW5kIHNob3VsZCBub3QgYmUgZXhlY3V0ZWQuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbnNoZWxsX2NvbW1hbmRfdmFyaWFibGVfaW5zdHJ1Y3Rpb25zLnB1c2goe1xyXG4gICAgdmFyaWFibGVfbmFtZTogXCJ7e2ZpbGVfcGF0aDpyZWxhdGl2ZX19IG9yIHt7ZmlsZV9wYXRoOmFic29sdXRlfX1cIixcclxuICAgIGluc3RydWN0aW9uczogXCJHaXZlcyBwYXRoIHRvIHRoZSBjdXJyZW50IGZpbGUsIGVpdGhlciBhcyBhYnNvbHV0ZSBmcm9tIHRoZSByb290IG9mIHRoZSBmaWxlIHN5c3RlbSwgb3IgYXMgcmVsYXRpdmUgZnJvbSB0aGUgcm9vdCBvZiB0aGUgT2JzaWRpYW4gdmF1bHQuXCIsXHJcbn0pO1xyXG5cclxuY2xhc3MgU2hlbGxDb21tYW5kVmFyaWFibGVfRm9sZGVyTmFtZSBleHRlbmRzIFNoZWxsQ29tbWFuZFZhcmlhYmxle1xyXG4gICAgbmFtZSA9IFwiZm9sZGVyX25hbWVcIjtcclxuICAgIGdldFZhbHVlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgbGV0IGZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xyXG4gICAgICAgIGlmICghZmlsZSkge1xyXG4gICAgICAgICAgICB0aGlzLm5vdGlmeShcIk5vIGZpbGUgaXMgYWN0aXZlIGF0IHRoZSBtb21lbnQuIE9wZW4gYSBmaWxlIG9yIGNsaWNrIGEgcGFuZSB0aGF0IGhhcyBhIGZpbGUgb3Blbi5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBudWxsIGluZGljYXRlcyB0aGF0IGdldHRpbmcgYSB2YWx1ZSBoYXMgZmFpbGVkIGFuZCB0aGUgY29tbWFuZCBzaG91bGQgbm90IGJlIGV4ZWN1dGVkLlxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWZpbGUucGFyZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMubm90aWZ5KFwiVGhlIGN1cnJlbnQgZmlsZSBkb2VzIG5vdCBoYXZlIGEgcGFyZW50IGZvciBzb21lIHN0cmFuZ2UgcmVhc29uLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIG51bGwgaW5kaWNhdGVzIHRoYXQgZ2V0dGluZyBhIHZhbHVlIGhhcyBmYWlsZWQgYW5kIHRoZSBjb21tYW5kIHNob3VsZCBub3QgYmUgZXhlY3V0ZWQuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmaWxlLnBhcmVudC5uYW1lO1xyXG4gICAgfVxyXG59XHJcbnNoZWxsX2NvbW1hbmRfdmFyaWFibGVfaW5zdHJ1Y3Rpb25zLnB1c2goe1xyXG4gICAgdmFyaWFibGVfbmFtZTogXCJ7e2ZvbGRlcl9uYW1lfX1cIixcclxuICAgIGluc3RydWN0aW9uczogXCJHaXZlcyB0aGUgY3VycmVudCBmaWxlJ3MgcGFyZW50IGZvbGRlciBuYW1lLiBObyBhbmNlc3RvciBmb2xkZXJzIGFyZSBpbmNsdWRlZC5cIixcclxufSk7XHJcblxyXG5jbGFzcyBTaGVsbENvbW1hbmRWYXJpYWJsZV9Gb2xkZXJQYXRoIGV4dGVuZHMgU2hlbGxDb21tYW5kVmFyaWFibGV7XHJcbiAgICBuYW1lID0gXCJmb2xkZXJfcGF0aFwiO1xyXG4gICAgaGFzX2FyZ3VtZW50ID0gdHJ1ZTtcclxuICAgIGdldFZhbHVlKG1vZGU6IHN0cmluZyk6IHN0cmluZ3xudWxsIHtcclxuICAgICAgICBsZXQgYWN0aXZlX2ZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xyXG4gICAgICAgIGlmIChhY3RpdmVfZmlsZSkge1xyXG4gICAgICAgICAgICBpZiAoYWN0aXZlX2ZpbGUucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZm9sZGVyID0gYWN0aXZlX2ZpbGUucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChtb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFic29sdXRlXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVQYXRoKGdldFZhdWx0QWJzb2x1dGVQYXRoKHRoaXMuYXBwKSArIFwiL1wiICsgZm9sZGVyLnBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZWxhdGl2ZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm9sZGVyLnBhdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnkoYFVua25vd24gbW9kZSBcIiR7bW9kZX1cIiEgVXNlIFwiYWJzb2x1dGVcIiBvciBcInJlbGF0aXZlXCIuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBudWxsIGluZGljYXRlcyB0aGF0IGdldHRpbmcgYSB2YWx1ZSBoYXMgZmFpbGVkIGFuZCB0aGUgY29tbWFuZCBzaG91bGQgbm90IGJlIGV4ZWN1dGVkLlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnkoXCJUaGUgY3VycmVudCBmaWxlIGRvZXMgbm90IGhhdmUgYSBwYXJlbnQgZm9yIHNvbWUgc3RyYW5nZSByZWFzb24uXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIG51bGwgaW5kaWNhdGVzIHRoYXQgZ2V0dGluZyBhIHZhbHVlIGhhcyBmYWlsZWQgYW5kIHRoZSBjb21tYW5kIHNob3VsZCBub3QgYmUgZXhlY3V0ZWQuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm5vdGlmeShcIk5vIGZpbGUgaXMgYWN0aXZlIGF0IHRoZSBtb21lbnQuIE9wZW4gYSBmaWxlIG9yIGNsaWNrIGEgcGFuZSB0aGF0IGhhcyBhIGZpbGUgb3Blbi5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBudWxsIGluZGljYXRlcyB0aGF0IGdldHRpbmcgYSB2YWx1ZSBoYXMgZmFpbGVkIGFuZCB0aGUgY29tbWFuZCBzaG91bGQgbm90IGJlIGV4ZWN1dGVkLlxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5zaGVsbF9jb21tYW5kX3ZhcmlhYmxlX2luc3RydWN0aW9ucy5wdXNoKHtcclxuICAgIHZhcmlhYmxlX25hbWU6IFwie3tmb2xkZXJfcGF0aDpyZWxhdGl2ZX19IG9yIHt7Zm9sZGVyX3BhdGg6YWJzb2x1dGV9fVwiLFxyXG4gICAgaW5zdHJ1Y3Rpb25zOiBcIkdpdmVzIHBhdGggdG8gdGhlIGN1cnJlbnQgZmlsZSdzIHBhcmVudCBmb2xkZXIsIGVpdGhlciBhcyBhYnNvbHV0ZSBmcm9tIHRoZSByb290IG9mIHRoZSBmaWxlIHN5c3RlbSwgb3IgYXMgcmVsYXRpdmUgZnJvbSB0aGUgcm9vdCBvZiB0aGUgT2JzaWRpYW4gdmF1bHQuXCIsXHJcbn0pO1xyXG5cclxuY2xhc3MgU2hlbGxDb21tYW5kVmFyaWFibGVfU2VsZWN0aW9uIGV4dGVuZHMgU2hlbGxDb21tYW5kVmFyaWFibGV7XHJcbiAgICBuYW1lID0gXCJzZWxlY3Rpb25cIjtcclxuICAgIGdldFZhbHVlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgbGV0IGVkaXRvciA9IGdldEVkaXRvcih0aGlzLmFwcCk7XHJcbiAgICAgICAgaWYgKG51bGwgPT09IGVkaXRvcikge1xyXG4gICAgICAgICAgICAvLyBQcm9iYWJseSB0aGUgbGVhZiBpcyBpbiBwcmV2aWV3IG1vZGUgb3Igc29tZSBvdGhlciBwcm9ibGVtIGhhcHBlbmVkLlxyXG4gICAgICAgICAgICAvLyBGSVhNRTogTWFrZSBpdCBwb3NzaWJsZSB0byB1c2UgdGhpcyBmZWF0dXJlIGFsc28gaW4gcHJldmlldyBtb2RlLlxyXG4gICAgICAgICAgICB0aGlzLm5vdGlmeShcIllvdSBuZWVkIHRvIHR1cm4gZWRpdGluZyBtb2RlIG9uLCBhcyBJJ20gbm90IGFibGUgdG8gZ2V0IHNlbGVjdGVkIHRleHQgd2hlbiBpbiBwcmV2aWV3IG1vZGUuIEJsYW1lIHRoZSBvbmUgd2hvIGRldmVsb3BlZCB0aGlzIHBsdWdpbiEgVGhpcyBzaG91bGQgYmUgZml4ZWQgaW4gdGhlIGZ1dHVyZS5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZWRpdG9yLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICB9XHJcbn1cclxuc2hlbGxfY29tbWFuZF92YXJpYWJsZV9pbnN0cnVjdGlvbnMucHVzaCh7XHJcbiAgICB2YXJpYWJsZV9uYW1lOiBcInt7c2VsZWN0aW9ufX1cIixcclxuICAgIGluc3RydWN0aW9uczogXCJHaXZlcyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRleHQuIEF0bSBvbmx5IHdvcmtzIGluIGVkaXRpbmcgbW9kZSwgbm90IGluIHByZXZpZXcgbW9kZSFcIixcclxufSk7XHJcblxyXG5jbGFzcyBTaGVsbENvbW1hbmRWYXJpYWJsZV9UaXRsZSBleHRlbmRzIFNoZWxsQ29tbWFuZFZhcmlhYmxle1xyXG4gICAgbmFtZSA9IFwidGl0bGVcIjtcclxuICAgIGdldFZhbHVlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgbGV0IGFjdGl2ZV9maWxlID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcclxuICAgICAgICBpZiAoYWN0aXZlX2ZpbGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZV9maWxlLmJhc2VuYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm5vdGlmeShcIk5vIGZpbGUgaXMgYWN0aXZlIGF0IHRoZSBtb21lbnQuIE9wZW4gYSBmaWxlIG9yIGNsaWNrIGEgcGFuZSB0aGF0IGhhcyBhIGZpbGUgb3Blbi5cIilcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG5zaGVsbF9jb21tYW5kX3ZhcmlhYmxlX2luc3RydWN0aW9ucy5wdXNoKHtcclxuICAgIHZhcmlhYmxlX25hbWU6IFwie3t0aXRsZX19XCIsXHJcbiAgICBpbnN0cnVjdGlvbnM6IFwiR2l2ZXMgdGhlIGN1cnJlbnQgZmlsZSBuYW1lIHdpdGhvdXQgYSBmaWxlIGV4dGVuc2lvbi5cIixcclxufSk7XHJcblxyXG5jbGFzcyBTaGVsbENvbW1hbmRWYXJpYWJsZV9WYXVsdFBhdGggZXh0ZW5kcyBTaGVsbENvbW1hbmRWYXJpYWJsZXtcclxuICAgIG5hbWUgPSBcInZhdWx0X3BhdGhcIjtcclxuICAgIGdldFZhbHVlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIGdldFZhdWx0QWJzb2x1dGVQYXRoKHRoaXMuYXBwKTtcclxuICAgIH1cclxufVxyXG5zaGVsbF9jb21tYW5kX3ZhcmlhYmxlX2luc3RydWN0aW9ucy5wdXNoKHtcclxuICAgIHZhcmlhYmxlX25hbWU6IFwie3t2YXVsdF9wYXRofX1cIixcclxuICAgIGluc3RydWN0aW9uczogXCJHaXZlcyB0aGUgT2JzaWRpYW4gdmF1bHQncyBhYnNvbHV0ZSBwYXRoIGZyb20gdGhlIHJvb3Qgb2YgdGhlIGZpbGVzeXN0ZW0uIFRoaXMgaXMgdGhlIHNhbWUgdGhhdCBpcyB1c2VkIGFzIGEgZGVmYXVsdCB3b3JraW5nIGRpcmVjdG9yeSBpZiB5b3UgZG8gbm90IGRlZmluZSBvbmUgbWFudWFsbHkuIElmIHlvdSBkZWZpbmUgYSB3b3JraW5nIGRpcmVjdG9yeSBtYW51YWxseSwgdGhpcyB2YXJpYWJsZSB3b24ndCBnaXZlIHlvdSB5b3VyIG1hbnVhbGx5IGRlZmluZWQgZGlyZWN0b3J5LCBpdCBhbHdheXMgZ2l2ZXMgdGhlIHZhdWx0J3Mgcm9vdCBkaXJlY3RvcnkuXCIsXHJcbn0pOyIsImltcG9ydCB7IEFwcCwgTm90aWNlLCBQbHVnaW4sIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcgfSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCB7ZXhlYywgRXhlY0V4Y2VwdGlvbn0gZnJvbSBcImNoaWxkX3Byb2Nlc3NcIjtcclxuaW1wb3J0IHtnZXRWYXVsdEFic29sdXRlUGF0aCwgaXNXaW5kb3dzfSBmcm9tIFwiLi9Db21tb25cIjtcclxuaW1wb3J0IHtcclxuXHRnZXRTaGVsbENvbW1hbmRWYXJpYWJsZUluc3RydWN0aW9ucyxcclxuXHRwYXJzZVNoZWxsQ29tbWFuZFZhcmlhYmxlc1xyXG59IGZyb20gXCIuL1NoZWxsQ29tbWFuZFZhcmlhYmxlUGFyc2VyXCI7XHJcblxyXG5pbnRlcmZhY2UgU2hlbGxDb21tYW5kc1BsdWdpblNldHRpbmdzIHtcclxuXHR3b3JraW5nX2RpcmVjdG9yeTogc3RyaW5nO1xyXG5cdGNvbW1hbmRzOiBzdHJpbmdbXTtcclxufVxyXG5cclxuY29uc3QgREVGQVVMVF9TRVRUSU5HUzogU2hlbGxDb21tYW5kc1BsdWdpblNldHRpbmdzID0ge1xyXG5cdHdvcmtpbmdfZGlyZWN0b3J5OiBcIlwiLFxyXG5cdGNvbW1hbmRzOiBbXVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaGVsbENvbW1hbmRzUGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcclxuXHRzZXR0aW5nczogU2hlbGxDb21tYW5kc1BsdWdpblNldHRpbmdzO1xyXG5cclxuXHRhc3luYyBvbmxvYWQoKSB7XHJcblx0XHRjb25zb2xlLmxvZygnbG9hZGluZyBwbHVnaW4nKTtcclxuXHJcblx0XHRhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xyXG5cclxuXHRcdC8vIE1ha2UgYWxsIGRlZmluZWQgc2hlbGwgY29tbWFuZHMgdG8gYXBwZWFyIGluIHRoZSBPYnNpZGlhbiBjb21tYW5kIGxpc3RcclxuXHRcdGZvciAobGV0IGNvbW1hbmRfaWQgaW4gdGhpcy5zZXR0aW5ncy5jb21tYW5kcykge1xyXG5cdFx0XHRsZXQgY29tbWFuZCA9IHRoaXMuc2V0dGluZ3MuY29tbWFuZHNbY29tbWFuZF9pZF07XHJcblx0XHRcdHRoaXMucmVnaXN0ZXJTaGVsbENvbW1hbmQocGFyc2VJbnQoY29tbWFuZF9pZCksIGNvbW1hbmQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgU2hlbGxDb21tYW5kc1NldHRpbmdzVGFiKHRoaXMuYXBwLCB0aGlzKSk7XHJcblx0fVxyXG5cclxuXHRyZWdpc3RlclNoZWxsQ29tbWFuZChjb21tYW5kX2lkOiBudW1iZXIsIGNvbW1hbmQ6IHN0cmluZykge1xyXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcclxuXHRcdFx0aWQ6IFwic2hlbGwtY29tbWFuZC1cIiArIGNvbW1hbmRfaWQsXHJcblx0XHRcdG5hbWU6IFwiRXhlY3V0ZTogXCIgKyBjb21tYW5kLFxyXG5cdFx0XHRjYWxsYmFjazogKCkgPT4ge1xyXG5cdFx0XHRcdHRoaXMuZXhlY3V0ZVNoZWxsQ29tbWFuZChjb21tYW5kKTtcclxuXHRcdFx0fVxyXG5cdFx0fSlcclxuXHR9XHJcblxyXG5cdGV4ZWN1dGVTaGVsbENvbW1hbmQoY29tbWFuZDogc3RyaW5nKSB7XHJcblx0XHRsZXQgcGFyc2VkX2NvbW1hbmQgPSBwYXJzZVNoZWxsQ29tbWFuZFZhcmlhYmxlcyh0aGlzLmFwcCwgY29tbWFuZCwgdHJ1ZSk7XHJcblx0XHRpZiAobnVsbCA9PT0gcGFyc2VkX2NvbW1hbmQpIHtcclxuXHRcdFx0Ly8gVGhlIGNvbW1hbmQgY291bGQgbm90IGJlIHBhcnNlZCBjb3JyZWN0bHkuXHJcblx0XHRcdGNvbnNvbGUubG9nKFwiUGFyc2luZyBjb21tYW5kIFwiICsgY29tbWFuZCArIFwiIGZhaWxlZC5cIik7XHJcblx0XHRcdC8vIE5vIG5lZWQgdG8gY3JlYXRlIGEgbm90aWNlIGhlcmUsIGJlY2F1c2UgdGhlIHBhcnNpbmcgcHJvY2VzcyBjcmVhdGVzIG5vdGljZXMgZXZlcnkgdGltZSBzb21ldGhpbmcgZ29lcyB3cm9uZy5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIFRoZSBjb21tYW5kIHdhcyBwYXJzZWQgY29ycmVjdGx5LlxyXG5cdFx0XHRjb25zb2xlLmxvZyhcIkV4ZWN1dGluZyBjb21tYW5kIFwiK3BhcnNlZF9jb21tYW5kK1wiIGluIFwiK3RoaXMuZ2V0V29ya2luZ0RpcmVjdG9yeSgpICsgXCIuLi5cIik7XHJcblx0XHRcdGV4ZWMocGFyc2VkX2NvbW1hbmQsIHtcclxuXHRcdFx0XHRcImN3ZFwiOiB0aGlzLmdldFdvcmtpbmdEaXJlY3RvcnkoKVxyXG5cdFx0XHR9LCAoZXJyb3I6IChFeGVjRXhjZXB0aW9ufG51bGwpKSA9PiB7XHJcblx0XHRcdFx0aWYgKG51bGwgIT09IGVycm9yKSB7XHJcblx0XHRcdFx0XHQvLyBTb21lIGVycm9yIG9jY3VycmVkXHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIkNvbW1hbmQgZXhlY3V0ZWQgYW5kIGZhaWxlZC4gRXJyb3IgbnVtYmVyOiBcIiArIGVycm9yLmNvZGUgKyBcIi4gTWVzc2FnZTogXCIgKyBlcnJvci5tZXNzYWdlKTtcclxuXHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJbXCIgKyBlcnJvci5jb2RlICsgXCJdOiBcIiArIGVycm9yLm1lc3NhZ2UpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHQvLyBObyBlcnJvcnNcclxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiQ29tbWFuZCBleGVjdXRlZCB3aXRob3V0IGVycm9ycy5cIilcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Z2V0V29ya2luZ0RpcmVjdG9yeSgpIHtcclxuXHRcdC8vIFJldHVybnMgZWl0aGVyIGEgdXNlciBkZWZpbmVkIHdvcmtpbmcgZGlyZWN0b3J5LCBvciBhbiBhdXRvbWF0aWNhbGx5IGRldGVjdGVkIG9uZS5cclxuXHRcdGxldCB3b3JraW5nX2RpcmVjdG9yeSA9IHRoaXMuc2V0dGluZ3Mud29ya2luZ19kaXJlY3Rvcnk7XHJcblx0XHRpZiAod29ya2luZ19kaXJlY3RvcnkubGVuZ3RoID09IDApIHtcclxuXHRcdFx0cmV0dXJuIGdldFZhdWx0QWJzb2x1dGVQYXRoKHRoaXMuYXBwKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB3b3JraW5nX2RpcmVjdG9yeTtcclxuXHR9XHJcblxyXG5cdG9udW5sb2FkKCkge1xyXG5cdFx0Y29uc29sZS5sb2coJ3VubG9hZGluZyBwbHVnaW4nKTtcclxuXHR9XHJcblxyXG5cdGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcclxuXHRcdHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xyXG5cdH1cclxuXHJcblx0YXN5bmMgc2F2ZVNldHRpbmdzKCkge1xyXG5cdFx0YXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcclxuXHR9XHJcbn1cclxuXHJcbmNsYXNzIFNoZWxsQ29tbWFuZHNTZXR0aW5nc1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xyXG5cdHBsdWdpbjogU2hlbGxDb21tYW5kc1BsdWdpbjtcclxuXHJcblx0Y29tbWFuZHM6IHN0cmluZ1tdOyAvLyBUaGlzIGhvbGRzIGFsbCBjb21tYW5kcyB0ZW1wb3JhcmlseTogZXZlcnkgdGltZSBhbiBjb21tYW5kIGZpZWxkIGZpcmVzIGl0cyBvbmNoYW5nZSBldmVudCAoZXZlcnkgdGltZSB1c2VyIHR5cGVzIGEgY2hhcmFjdGVyKSwgdGhlIGNoYW5nZSB3aWxsIGJlIHJlY29yZGVkIGhlcmUuIE9ubHkgd2hlbiB0aGUgdXNlciBoaXRzIHRoZSBhcHBseSBjaGFuZ2VzIGJ1dHRvbiwgd2lsbCB0aGlzIGFycmF5J3MgY29udGVudCBiZSBjb3BpZWQgb3ZlciB0byB0aGlzLnBsdWdpbi5zZXR0aW5ncy5jb21tYW5kcyAuXHJcblxyXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IFNoZWxsQ29tbWFuZHNQbHVnaW4pIHtcclxuXHRcdHN1cGVyKGFwcCwgcGx1Z2luKTtcclxuXHRcdHRoaXMucGx1Z2luID0gcGx1Z2luO1xyXG5cdFx0dGhpcy5jb21tYW5kcyA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmNvbW1hbmRzO1xyXG5cdH1cclxuXHJcblx0ZGlzcGxheSgpOiB2b2lkIHtcclxuXHRcdGxldCB7Y29udGFpbmVyRWx9ID0gdGhpcztcclxuXHJcblx0XHRjb250YWluZXJFbC5lbXB0eSgpO1xyXG5cclxuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHt0ZXh0OiBcIlNoZWxsIGNvbW1hbmRzXCJ9KTtcclxuXHJcblx0XHQvLyBcIldvcmtpbmcgZGlyZWN0b3J5XCIgZmllbGRcclxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG5cdFx0XHQuc2V0TmFtZShcIldvcmtpbmcgZGlyZWN0b3J5XCIpXHJcblx0XHRcdC5zZXREZXNjKFwiRW50ZXIgYSBkaXJlY3Rvcnkgd2hlcmUgeW91ciBjb21tYW5kcyB3aWxsIGJlIHJ1bi4gSWYgZW1wdHksIGRlZmF1bHRzIHRvIHlvdXIgdmF1bHQncyBsb2NhdGlvbi5cIilcclxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcblx0XHRcdFx0LnNldFBsYWNlaG9sZGVyKGdldFZhdWx0QWJzb2x1dGVQYXRoKHRoaXMuYXBwKSlcclxuXHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Mud29ya2luZ19kaXJlY3RvcnkpXHJcblx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJDaGFuZ2luZyB3b3JraW5nX2RpcmVjdG9yeSB0byBcIiArIHZhbHVlKTtcclxuXHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLndvcmtpbmdfZGlyZWN0b3J5ID0gdmFsdWU7XHJcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHQpXHJcblxyXG5cdFx0Ly8gVGlwcyB3aGVuIHRoZSB1c2VyIGhhcyBhbHJlYWR5IGRlZmluZWQgc29tZSBjb21tYW5kc1xyXG5cdFx0aWYgKHRoaXMuY29tbWFuZHMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgncCcsIHt0ZXh0OiBcIlRvIHJlbW92ZSBhIGNvbW1hbmQsIGNsZWFyIGl0cyB0ZXh0IGZpZWxkLiBOb3RlIHRoYXQgaWYgeW91IHJlbW92ZSBjb21tYW5kcywgb3RoZXIgc2hlbGwgY29tbWFuZHMgY2FuIHN3aXRjaCBwbGFjZSBhbmQgaG90a2V5cyBtaWdodCBjaGFuZ2UhIEFsd2F5cyBjaGVjayB5b3VyIHNoZWxsIGNvbW1hbmRzJyBob3RrZXkgY29uZmlndXJhdGlvbnMgYWZ0ZXIgcmVtb3Zpbmcgb3IgbWFraW5nIGNoYW5nZXMgdG8gc2hlbGwgY29tbWFuZHMhXCJ9KTtcclxuXHRcdFx0aWYgKGlzV2luZG93cygpKSBjb250YWluZXJFbC5jcmVhdGVFbCgncCcsIHt0ZXh0OiBcIlRpcCBmb3IgV2luZG93czogSWYgeW91IGdldCBhbiBlcnJvciBzdGFydGluZyB3aXRoIFxcXCJbMjU5XTogQ29tbWFuZCBmYWlsZWQ6XFxcIiBldmVuIHRob3VnaCB0aGUgZXhlY3V0aW9uIHdvcmtzIG9rLCB5b3UgY2FuIHRyeSB0byBwcmVmaXggeW91ciBjb21tYW5kIHdpdGggXFxcInN0YXJ0IFxcXCIuIEUuZy4gXFxcInN0YXJ0IGdpdC1ndWlcXFwiLlwifSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQSA8ZGl2PiBlbGVtZW50IGZvciBhbGwgY29tbWFuZCBpbnB1dCBmaWVsZHMuIE5ldyBjb21tYW5kIGZpZWxkcyBjYW4gYmUgY3JlYXRlZCBhdCB0aGUgYm90dG9tIG9mIHRoaXMgZWxlbWVudC5cclxuXHRcdGxldCBjb21tYW5kX2ZpZWxkc19jb250YWluZXIgPSBjb250YWluZXJFbC5jcmVhdGVFbChcImRpdlwiKTtcclxuXHJcblx0XHQvLyBGaWVsZHMgZm9yIG1vZGlmeWluZyBleGlzdGluZyBjb21tYW5kc1xyXG5cdFx0Zm9yIChsZXQgY29tbWFuZF9pZCBpbiB0aGlzLmNvbW1hbmRzKSB7XHJcblx0XHRcdHRoaXMuY3JlYXRlQ29tbWFuZEZpZWxkKGNvbW1hbmRfZmllbGRzX2NvbnRhaW5lciwgcGFyc2VJbnQoY29tbWFuZF9pZCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFwiQXBwbHkgY2hhbmdlc1wiIGJ1dHRvblxyXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcblx0XHRcdC5zZXREZXNjKFwiQ2xpY2sgdGhpcyB3aGVuIHlvdSBtYWtlIGNoYW5nZXMgdG8gY29tbWFuZHMuIE90aGVyIHNldHRpbmdzIGFyZSBhcHBsaWVkIGF1dG9tYXRpY2FsbHkuXCIpXHJcblx0XHRcdC5hZGRCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxyXG5cdFx0XHRcdC5zZXRCdXR0b25UZXh0KFwiQVBQTFkgQ0hBTkdFU1wiKVxyXG5cdFx0XHRcdC5vbkNsaWNrKGFzeW5jICgpID0+IHtcclxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiVXBkYXRpbmcgc2hlbGwgY29tbWFuZCBzZXR0aW5ncy4uLlwiKVxyXG5cdFx0XHRcdFx0Zm9yIChsZXQgY29tbWFuZF9pZCBpbiB0aGlzLmNvbW1hbmRzKSB7XHJcblx0XHRcdFx0XHRcdGxldCBjb21tYW5kID0gdGhpcy5jb21tYW5kc1tjb21tYW5kX2lkXTtcclxuXHRcdFx0XHRcdFx0aWYgKGNvbW1hbmQubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdFx0XHRcdC8vIERlZmluZS9jaGFuZ2UgYSBjb21tYW5kXHJcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJDb21tYW5kIFwiICsgY29tbWFuZF9pZCArIFwiIGdvbm5hIGNoYW5nZSB0bzogXCIgKyBjb21tYW5kKTtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5jb21tYW5kc1tjb21tYW5kX2lkXSA9IGNvbW1hbmQ7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5wbHVnaW4ucmVnaXN0ZXJTaGVsbENvbW1hbmQocGFyc2VJbnQoY29tbWFuZF9pZCksIGNvbW1hbmQpO1xyXG5cdFx0XHRcdFx0XHRcdC8vIFRPRE86IEhvdyB0byByZW1vdmUgdGhlIG9sZCBjb21tYW5kIGZyb20gT2JzaWRpYW4gY29tbWFuZHMgbGlzdD9cclxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIkNvbW1hbmQgY2hhbmdlZC5cIik7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGEgY29tbWFuZFxyXG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiQ29tbWFuZCBcIiArIGNvbW1hbmRfaWQgKyBcIiBnb25uYSBiZSByZW1vdmVkLlwiKTtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5jb21tYW5kcy5zcGxpY2UocGFyc2VJbnQoY29tbWFuZF9pZCksMSk7IC8vIFdoeSAucmVtb3ZlKCkgZG9lcyBub3Qgd29yaz8gOiggOiggOihcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogSG93IHRvIHJlbW92ZSBhIGNvbW1hbmQgZnJvbSBPYnNpZGlhbiBjb21tYW5kcyBsaXN0P1xyXG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiQ29tbWFuZCByZW1vdmVkLlwiKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIlNoZWxsIGNvbW1hbmQgc2V0dGluZ3MgdXBkYXRlZC5cIik7XHJcblx0XHRcdFx0XHRuZXcgTm90aWNlKFwiQXBwbGllZCFcIik7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0KVxyXG5cdFx0O1xyXG5cclxuXHRcdC8vIFwiTmV3IGNvbW1hbmRcIiBidXR0b25cclxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG5cdFx0XHQuYWRkQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cclxuXHRcdFx0XHQuc2V0QnV0dG9uVGV4dChcIk5ldyBjb21tYW5kXCIpXHJcblx0XHRcdFx0Lm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xyXG5cdFx0XHRcdFx0dGhpcy5jb21tYW5kcy5wdXNoKFwiXCIpOyAvLyBUaGUgY29tbWFuZCBpcyBqdXN0IGFuIGVtcHR5IHN0cmluZyBhdCB0aGlzIHBvaW50LlxyXG5cdFx0XHRcdFx0dGhpcy5jcmVhdGVDb21tYW5kRmllbGQoY29tbWFuZF9maWVsZHNfY29udGFpbmVyLCB0aGlzLmNvbW1hbmRzLmxlbmd0aC0xKTtcclxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiTmV3IGVtcHR5IGNvbW1hbmQgY3JlYXRlZC5cIik7XHJcblx0XHRcdFx0XHRuZXcgTm90aWNlKFwiUmVtZW1iZXIgdG8gY2xpY2sgQVBQTFkgQ0hBTkdFUyBhZnRlciB5b3UgaGF2ZSB3cml0dGVuIHRoZSBuZXcgY29tbWFuZCFcIik7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0KVxyXG5cdFx0O1xyXG5cclxuXHRcdC8vIFZhcmlhYmxlIGluc3RydWN0aW9uc1xyXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoXCJoMlwiLCB7dGV4dDogXCJWYXJpYWJsZXNcIn0pO1xyXG5cdFx0Z2V0U2hlbGxDb21tYW5kVmFyaWFibGVJbnN0cnVjdGlvbnMoKS5mb3JFYWNoKChpbnN0cnVjdGlvbnMpID0+IHtcclxuXHRcdFx0bGV0IHBhcmFncmFwaCA9IGNvbnRhaW5lckVsLmNyZWF0ZUVsKFwicFwiKTtcclxuXHRcdFx0Ly8gQHRzLWlnbm9yZVxyXG5cdFx0XHRwYXJhZ3JhcGguY3JlYXRlRWwoXCJzdHJvbmdcIiwge3RleHQ6IGluc3RydWN0aW9ucy52YXJpYWJsZV9uYW1lICsgXCIgXCJ9KTtcclxuXHRcdFx0Ly8gQHRzLWlnbm9yZVxyXG5cdFx0XHRwYXJhZ3JhcGguY3JlYXRlRWwoXCJzcGFuXCIsIHt0ZXh0OiBpbnN0cnVjdGlvbnMuaW5zdHJ1Y3Rpb25zfSk7XHJcblx0XHR9KTtcclxuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKFwicFwiLCB7dGV4dDogXCJXaGVuIHlvdSB0eXBlIHZhcmlhYmxlcyBpbnRvIGNvbW1hbmRzLCBhIHByZXZpZXcgdGV4dCBhcHBlYXJzIHVuZGVyIHRoZSBjb21tYW5kIGZpZWxkIHRvIHNob3cgaG93IHRoZSBjb21tYW5kIHdpbGwgbG9vayBsaWtlIHdoZW4gaXQgZ2V0cyBleGVjdXRlZCB3aXRoIHZhcmlhYmxlcyBzdWJzdGl0dXRlZCB3aXRoIHRoZWlyIHJlYWwgdmFsdWVzLlwifSlcclxuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKFwicFwiLCB7dGV4dDogXCJUaGVyZSBpcyBubyB3YXkgdG8gZXNjYXBlIHZhcmlhYmxlIHBhcnNpbmcuIElmIHlvdSBuZWVkIHt7IH19IGNoYXJhY3RlcnMgaW4geW91ciBjb21tYW5kLCB0aGV5IHdvbid0IGJlIHBhcnNlZCBhcyB2YXJpYWJsZXMgYXMgbG9uZyBhcyB0aGV5IGRvIG5vdCBjb250YWluIGFueSBvZiB0aGUgdmFyaWFibGUgbmFtZXMgbGlzdGVkIGJlbG93LiBJZiB5b3Ugd291bGQgbmVlZCB0byBwYXNzIGUuZy4ge3t0aXRsZX19IGxpdGVyYWxseSB0byB5b3VyIGNvbW1hbmQsIHRoZXJlIGlzIG5vIHdheSB0byBkbyBpdCBhdG0sIHBsZWFzZSByYWlzZSBhbiBpc3N1ZSBpbiBHaXRIdWIuXCJ9KVxyXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoXCJwXCIsIHt0ZXh0OiBcIkFsbCB2YXJpYWJsZXMgdGhhdCBhY2Nlc3MgdGhlIGN1cnJlbnQgZmlsZSwgbWF5IGNhdXNlIHRoZSBjb21tYW5kIHByZXZpZXcgdG8gZmFpbCBpZiB5b3UgaGFkIG5vIGZpbGUgcGFuZWwgYWN0aXZlIHdoZW4geW91IG9wZW5lZCB0aGUgc2V0dGluZ3Mgd2luZG93IC0gZS5nLiB5b3UgaGFkIGZvY3VzIG9uIGdyYXBoIHZpZXcgaW5zdGVhZCBvZiBhIG5vdGUgPSBubyBmaWxlIGlzIGN1cnJlbnRseSBhY3RpdmUuIEJ1dCB0aGlzIGRvZXMgbm90IGJyZWFrIGFueXRoaW5nIGVsc2UgdGhhbiB0aGUgcHJldmlldy5cIn0pXHJcblx0fVxyXG5cclxuXHRjcmVhdGVDb21tYW5kRmllbGQoY29udGFpbmVyX2VsZW1lbnQ6IEhUTUxFbGVtZW50LCBjb21tYW5kX2lkOiBudW1iZXIpIHtcclxuXHRcdGxldCBjb21tYW5kID0gdGhpcy5jb21tYW5kc1tjb21tYW5kX2lkXTtcclxuXHRcdGxldCBzZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGFpbmVyX2VsZW1lbnQpXHJcblx0XHRcdC5zZXROYW1lKFwiQ29tbWFuZCAjXCIgKyBjb21tYW5kX2lkKVxyXG5cdFx0XHQuc2V0RGVzYyh0aGlzLmdldENvbW1hbmRQcmV2aWV3KGNvbW1hbmQpKVxyXG5cdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHRleHRcclxuXHRcdFx0XHQuc2V0UGxhY2Vob2xkZXIoXCJFbnRlciB5b3VyIGNvbW1hbmRcIilcclxuXHRcdFx0XHQuc2V0VmFsdWUoY29tbWFuZClcclxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcblx0XHRcdFx0XHR0aGlzLmNvbW1hbmRzW2NvbW1hbmRfaWRdID0gdmFsdWU7XHJcblx0XHRcdFx0XHRzZXR0aW5nLnNldERlc2ModGhpcy5nZXRDb21tYW5kUHJldmlldyh2YWx1ZSkpO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdClcclxuXHRcdDtcclxuXHR9XHJcblxyXG5cdGdldENvbW1hbmRQcmV2aWV3KGNvbW1hbmQ6IHN0cmluZykge1xyXG5cdFx0bGV0IHBhcnNlZF9jb21tYW5kID0gcGFyc2VTaGVsbENvbW1hbmRWYXJpYWJsZXModGhpcy5hcHAsIGNvbW1hbmQsIGZhbHNlKTsgLy8gZmFsc2U6IGRpc2FibGVzIG5vdGlmaWNhdGlvbnMgaWYgdmFyaWFibGVzIGhhdmUgc3ludGF4IGVycm9ycy5cclxuXHRcdGlmIChudWxsID09PSBwYXJzZWRfY29tbWFuZCkge1xyXG5cdFx0XHRyZXR1cm4gXCJbRXJyb3Igd2hpbGUgcGFyc2luZyB2YXJpYWJsZXMuXVwiO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHBhcnNlZF9jb21tYW5kO1xyXG5cdH1cclxufSJdLCJuYW1lcyI6WyJGaWxlU3lzdGVtQWRhcHRlciIsIk1hcmtkb3duVmlldyIsIk5vdGljZSIsIm1vbWVudCIsIm5vcm1hbGl6ZVBhdGgiLCJQbHVnaW4iLCJleGVjIiwiUGx1Z2luU2V0dGluZ1Rh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
